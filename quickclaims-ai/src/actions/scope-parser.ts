"use server";

import Anthropic from "@anthropic-ai/sdk";
import { requireRole } from "@/lib/auth";

/**
 * Extracted data from an insurance scope PDF
 */
export interface ExtractedScopeData {
  // Policyholder Info
  policyholderName: string | null;
  policyholderEmail: string | null;
  policyholderPhone: string | null;

  // Property Address
  lossAddress: string | null;
  lossCity: string | null;
  lossState: string | null;
  lossZip: string | null;

  // Claim Info
  claimNumber: string | null;
  policyNumber: string | null;
  dateOfLoss: string | null; // ISO date string
  lossType: "hail" | "wind" | "fire" | "other" | null;

  // Insurance Info
  carrierName: string | null;
  adjusterName: string | null;
  adjusterPhone: string | null;
  adjusterEmail: string | null;

  // Roof Details
  totalSquares: number | null;
  roofRCV: number | null;
  initialRCV: number | null;

  // Metadata
  confidence: "high" | "medium" | "low";
  extractionNotes: string[];
}

/**
 * Parse an insurance scope PDF and extract claim data using Claude AI
 */
export async function parseInsuranceScope(formData: FormData): Promise<{
  success: boolean;
  data?: ExtractedScopeData;
  error?: string;
}> {
  // Verify user has permission
  await requireRole(["admin", "manager", "estimator"]);

  const file = formData.get("file") as File | null;

  if (!file || !(file instanceof File)) {
    return { success: false, error: "No file provided" };
  }

  if (file.type !== "application/pdf") {
    return { success: false, error: "File must be a PDF" };
  }

  // Check file size (max 20MB for PDF processing)
  const MAX_SIZE = 20 * 1024 * 1024;
  if (file.size > MAX_SIZE) {
    return { success: false, error: "File too large. Maximum size is 20MB" };
  }

  // Check for API key
  if (!process.env.ANTHROPIC_API_KEY) {
    return {
      success: false,
      error: "ANTHROPIC_API_KEY not configured. Please add it to your environment variables."
    };
  }

  try {
    // Convert file to base64
    let arrayBuffer: ArrayBuffer;
    try {
      arrayBuffer = await file.arrayBuffer();
    } catch (bufferError) {
      console.error("[ScopeParser] Failed to read file buffer:", bufferError);
      return {
        success: false,
        error: "Failed to read PDF file. The file may be corrupted or unreadable."
      };
    }

    const base64 = Buffer.from(arrayBuffer).toString("base64");
    console.log(`[ScopeParser] Processing PDF: ${file.name}, size: ${file.size} bytes, base64 length: ${base64.length}`);

    // Initialize Anthropic client
    const anthropic = new Anthropic({
      apiKey: process.env.ANTHROPIC_API_KEY,
    });

    // Call Claude with the PDF
    const response = await anthropic.messages.create({
      model: "claude-sonnet-4-20250514",
      max_tokens: 4096,
      messages: [
        {
          role: "user",
          content: [
            {
              type: "document",
              source: {
                type: "base64",
                media_type: "application/pdf",
                data: base64,
              },
            },
            {
              type: "text",
              text: `You are an expert at extracting data from insurance scope documents (also called insurance estimates or loss reports). These are typically generated by insurance companies after inspecting property damage.

Please extract the following information from this insurance scope PDF and return it as a JSON object. Be precise and extract exactly what you see - do not make up or infer data that isn't clearly present.

Extract these fields:
1. policyholderName - The insured person's name (look for "Insured:", "Policyholder:", "Customer:", etc.)
2. policyholderEmail - The insured's email address
3. policyholderPhone - The insured's phone number (look for "Home:", "Phone:", "Tel:", etc.)
4. lossAddress - The property street address where the loss occurred (look for "Property:", "Loss Location:", "Property Address:")
5. lossCity - The city
6. lossState - The state (2-letter code like TX, FL, etc.)
7. lossZip - The ZIP code (5 digits, may include -4 extension)
8. claimNumber - The insurance claim number
9. policyNumber - The policy number
10. dateOfLoss - The date the loss/damage occurred (format as YYYY-MM-DD)
11. lossType - The type of loss. Look for "Type of Loss:" and categorize as one of: "hail", "wind", "fire", or "other". If it mentions both wind and hail, use "hail".
12. carrierName - The insurance company name (look for "Insurance Company:", company logo, letterhead)
13. adjusterName - The claim representative or adjuster name (look for "Claim Rep:", "Adjuster:", "Estimator:")
14. adjusterPhone - The adjuster's phone number (look for "Business:", near adjuster name)
15. adjusterEmail - The adjuster's email address
16. totalSquares - The total roof squares (look for "Number of Squares" or roof area measurements. 1 square = 100 sq ft)
17. roofRCV - The Replacement Cost Value for the roof/dwelling roof section specifically (look for "Totals: Dwelling Roof" RCV or similar)
18. initialRCV - The total Replacement Cost Value for the entire claim (look for "Replacement Cost Value" in the summary section)

Also provide:
- confidence: Rate your overall extraction confidence as "high", "medium", or "low"
- extractionNotes: An array of strings noting any issues, ambiguities, or fields you couldn't find

Return ONLY a valid JSON object with these exact field names. Use null for any fields you cannot find or extract. For numbers, return actual numbers not strings. For dates, use YYYY-MM-DD format.

Example output format:
{
  "policyholderName": "John Smith",
  "policyholderEmail": "john@example.com",
  "policyholderPhone": "(555) 123-4567",
  "lossAddress": "123 Main Street",
  "lossCity": "Austin",
  "lossState": "TX",
  "lossZip": "78701",
  "claimNumber": "CLM-2024-12345",
  "policyNumber": "POL-12345",
  "dateOfLoss": "2024-05-15",
  "lossType": "hail",
  "carrierName": "State Farm Insurance",
  "adjusterName": "Jane Doe",
  "adjusterPhone": "(800) 555-1234",
  "adjusterEmail": "adjuster@insurance.com",
  "totalSquares": 25.5,
  "roofRCV": 15000.00,
  "initialRCV": 25000.00,
  "confidence": "high",
  "extractionNotes": ["Policy number found in header"]
}`,
            },
          ],
        },
      ],
    });

    console.log(`[ScopeParser] API response received, stop_reason: ${response.stop_reason}`);

    // Extract the text content from the response
    const textBlock = response.content.find((block) => block.type === "text");
    if (!textBlock || textBlock.type !== "text") {
      console.error("[ScopeParser] No text block in response:", JSON.stringify(response.content));
      return { success: false, error: "No text response from AI. The PDF may not have been processed correctly." };
    }

    console.log(`[ScopeParser] Response text length: ${textBlock.text.length}`);

    // Parse the JSON response
    let extractedData: ExtractedScopeData;
    try {
      // Try to extract JSON from the response (it might be wrapped in markdown code blocks)
      let jsonStr = textBlock.text;

      // Remove markdown code blocks if present
      const jsonMatch = jsonStr.match(/```(?:json)?\s*([\s\S]*?)```/);
      if (jsonMatch) {
        jsonStr = jsonMatch[1];
      }

      extractedData = JSON.parse(jsonStr.trim());
      console.log(`[ScopeParser] Successfully parsed JSON, confidence: ${extractedData.confidence}`);
    } catch (parseError) {
      console.error("[ScopeParser] Failed to parse AI response:", textBlock.text.substring(0, 500));
      return {
        success: false,
        error: "Failed to parse extracted data. The AI response was not valid JSON. Please try again."
      };
    }

    // Validate and sanitize the extracted data
    const sanitizedData: ExtractedScopeData = {
      policyholderName: extractedData.policyholderName || null,
      policyholderEmail: extractedData.policyholderEmail || null,
      policyholderPhone: extractedData.policyholderPhone || null,
      lossAddress: extractedData.lossAddress || null,
      lossCity: extractedData.lossCity || null,
      lossState: extractedData.lossState?.toUpperCase().substring(0, 2) || null,
      lossZip: extractedData.lossZip || null,
      claimNumber: extractedData.claimNumber || null,
      policyNumber: extractedData.policyNumber || null,
      dateOfLoss: extractedData.dateOfLoss || null,
      lossType: validateLossType(extractedData.lossType),
      carrierName: extractedData.carrierName || null,
      adjusterName: extractedData.adjusterName || null,
      adjusterPhone: extractedData.adjusterPhone || null,
      adjusterEmail: extractedData.adjusterEmail || null,
      totalSquares: typeof extractedData.totalSquares === "number" ? extractedData.totalSquares : null,
      roofRCV: typeof extractedData.roofRCV === "number" ? extractedData.roofRCV : null,
      initialRCV: typeof extractedData.initialRCV === "number" ? extractedData.initialRCV : null,
      confidence: validateConfidence(extractedData.confidence),
      extractionNotes: Array.isArray(extractedData.extractionNotes) ? extractedData.extractionNotes : [],
    };

    return { success: true, data: sanitizedData };
  } catch (error) {
    console.error("[ScopeParser] Error parsing insurance scope:", error);

    if (error instanceof Anthropic.APIError) {
      console.error(`[ScopeParser] API Error - Status: ${error.status}, Message: ${error.message}`);
      if (error.status === 401) {
        return { success: false, error: "Invalid API key. Please check your ANTHROPIC_API_KEY configuration." };
      }
      if (error.status === 429) {
        return { success: false, error: "Rate limited by AI service. Please wait a moment and try again." };
      }
      if (error.status === 400) {
        return { success: false, error: "Invalid request. The PDF may be encrypted, password-protected, or in an unsupported format." };
      }
      if (error.status === 413) {
        return { success: false, error: "PDF file is too large for processing. Try a smaller file." };
      }
      return { success: false, error: `AI service error (${error.status}): ${error.message}` };
    }

    // Check for network errors
    if (error instanceof Error) {
      if (error.message.includes("fetch") || error.message.includes("network")) {
        return { success: false, error: "Network error connecting to AI service. Please check your internet connection and try again." };
      }
      return { success: false, error: `Error: ${error.message}` };
    }

    return {
      success: false,
      error: "An unexpected error occurred while processing the PDF. Please try again."
    };
  }
}

function validateLossType(value: unknown): ExtractedScopeData["lossType"] {
  if (value === "hail" || value === "wind" || value === "fire" || value === "other") {
    return value;
  }
  return null;
}

function validateConfidence(value: unknown): ExtractedScopeData["confidence"] {
  if (value === "high" || value === "medium" || value === "low") {
    return value;
  }
  return "low";
}
